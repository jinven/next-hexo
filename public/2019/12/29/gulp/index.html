<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="task每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。由于某些平台的限制而不支持异步任务，因此 gulp 还提供了一个漂亮 替代品。">
<meta property="og:type" content="article">
<meta property="og:title" content="gulp">
<meta property="og:url" content="http://yoursite.com/2019/12/29/gulp/index.html">
<meta property="og:site_name" content="Jinwen">
<meta property="og:description" content="task每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。由于某些平台的限制而不支持异步任务，因此 gulp 还提供了一个漂亮 替代品。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gulpjs.com/img/docs-gulp-tasks-command.png">
<meta property="article:published_time" content="2019-12-29T08:02:08.000Z">
<meta property="article:modified_time" content="2019-12-30T01:29:45.276Z">
<meta property="article:author" content="Jinwen">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gulpjs.com/img/docs-gulp-tasks-command.png">

<link rel="canonical" href="http://yoursite.com/2019/12/29/gulp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>gulp | Jinwen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jinwen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/29/gulp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jinwen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinwen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gulp
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-29 16:02:08" itemprop="dateCreated datePublished" datetime="2019-12-29T16:02:08+08:00">2019-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-30 09:29:45" itemprop="dateModified" datetime="2019-12-30T09:29:45+08:00">2019-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="task"><a href="#task" class="headerlink" title="task"></a>task</h1><p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable 类型值的函数。由于某些平台的限制而不支持异步任务，因此 gulp 还提供了一个漂亮 <a href="https://www.gulpjs.com.cn/docs/getting-started/async-completion#using-async-await" target="_blank" rel="noopener">替代品</a>。</p>
<a id="more"></a>

<h2 id="导出任务"><a href="#导出任务" class="headerlink" title="导出任务"></a>导出任务</h2><p>任务（tasks）可以是 public（公开） 或 private（私有） 类型的。</p>
<ul>
<li>公开任务（Public tasks） 从 gulpfile 中被导出（export），可以通过 gulp 命令直接调用。</li>
<li>私有任务（Private tasks） 被设计为在内部使用，通常作为 series() 或 parallel() 组合的组成部分。</li>
</ul>
<p>一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `clean` 函数并未被导出（export），因此被认为是私有任务（private task）。</span></span><br><span class="line"><span class="comment">// 它仍然可以被用在 `series()` 组合中。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `build` 函数被导出（export）了，因此它是一个公开任务（public task），并且可以被 `gulp` 命令直接调用。</span></span><br><span class="line"><span class="comment">// 它也仍然可以被用在 `series()` 组合中。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = build;</span><br><span class="line">exports.default = series(clean, build);</span><br></pre></td></tr></table></figure>

<p><img src="https://gulpjs.com/img/docs-gulp-tasks-command.png" alt="sfa"></p>
<h2 id="组合任务"><a href="#组合任务" class="headerlink" title="组合任务"></a>组合任务</h2><p>Gulp 提供了两个强大的组合方法： series() 和 parallel()，允许将多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务（task）函数或已经组合的操作。series() 和 parallel() 可以互相嵌套至任意深度。</p>
<p>如果需要让任务（task）按顺序执行，请使用 series() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(transpile, bundle);</span><br></pre></td></tr></table></figure>

<p>对于希望以最大并发来运行的任务（tasks），可以使用 parallel() 方法将它们组合起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = parallel(javascript, css);</span><br></pre></td></tr></table></figure>

<p>当 series() 或 parallel() 被调用时，任务（tasks）被立即组合在一起。这就允许在组合中进行改变，而不需要在单个任务（task）中进行条件判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minify</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">livereload</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  exports.build = series(transpile, minify);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  exports.build = series(transpile, livereload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>series() 和 parallel() 可以被嵌套到任意深度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cssTranspile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cssMinify</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsTranspile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsBundle</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsMinify</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(</span><br><span class="line">  clean,</span><br><span class="line">  parallel(</span><br><span class="line">    cssTranspile,</span><br><span class="line">    series(jsTranspile, jsBundle)</span><br><span class="line">  ),</span><br><span class="line">  parallel(cssMinify, jsMinify),</span><br><span class="line">  publish</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>当一个组合操作执行时，这个组合中的每一个任务每次被调用时都会被执行。例如，在两个不同的任务（task）之间调用的 clean 任务（task）将被执行两次，并且将导致不可预期的结果。因此，最好重构组合中的 clean 任务（task）。</p>
<p>如果你有如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is INCORRECT</span></span><br><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> css = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> javascript = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">exports.build = parallel(css, javascript);</span><br></pre></td></tr></table></figure>

<p>重构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(clean, parallel(css, javascript));</span><br></pre></td></tr></table></figure>

<h1 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h1><p>Node 库以多种方式处理异步功能。最常见的模式是 error-first callbacks，但是你还可能会遇到 streams、promises、event emitters、child processes, 或 observables。gulp 任务（task）规范化了所有这些类型的异步功能。</p>
<h2 id="任务（task）完成通知"><a href="#任务（task）完成通知" class="headerlink" title="任务（task）完成通知"></a>任务（task）完成通知</h2><p>当从任务（task）中返回 stream、promise、event emitter、child process 或 observable 时，成功或错误值将通知 gulp 是否继续执行或结束。如果任务（task）出错，gulp 将立即结束执行并显示该错误。</p>
<p>当使用 series() 组合多个任务（task）时，任何一个任务（task）的错误将导致整个任务组合结束，并且不会进一步执行其他任务。当使用 parallel() 组合多个任务（task）时，一个任务的错误将结束整个任务组合的结束，但是其他并行的任务（task）可能会执行完，也可能没有执行完。</p>
<h2 id="返回-streams"><a href="#返回-streams" class="headerlink" title="返回 streams"></a>返回 streams</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'*.js'</span>)</span><br><span class="line">    .pipe(dest(<span class="string">'output'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = streamTask;</span><br></pre></td></tr></table></figure>

<h2 id="返回-promise"><a href="#返回-promise" class="headerlink" title="返回 promise"></a>返回 promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'the value is ignored'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = promiseTask;</span><br></pre></td></tr></table></figure>

<h2 id="返回-event-emitter"><a href="#返回-event-emitter" class="headerlink" title="返回 event emitter"></a>返回 event emitter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventEmitterTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">  <span class="comment">// Emit has to happen async otherwise gulp isn't listening yet</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> emitter.emit(<span class="string">'finish'</span>), <span class="number">250</span>);</span><br><span class="line">  <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = eventEmitterTask;</span><br></pre></td></tr></table></figure>

<h2 id="返回-child-process"><a href="#返回-child-process" class="headerlink" title="返回 child process"></a>返回 child process</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childProcessTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> exec(<span class="string">'date'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = childProcessTask;</span><br></pre></td></tr></table></figure>

<h2 id="返回-observable"><a href="#返回-observable" class="headerlink" title="返回 observable"></a>返回 observable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observable &#125; = <span class="built_in">require</span>(<span class="string">'rxjs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observableTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Observable.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = observableTask;</span><br></pre></td></tr></table></figure>

<h2 id="使用-callback"><a href="#使用-callback" class="headerlink" title="使用 callback"></a>使用 callback</h2><p>如果任务（task）不返回任何内容，则必须使用 callback 来指示任务已完成。在如下示例中，callback 将作为唯一一个名为 cb() 的参数传递给你的任务（task）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackTask</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `cb()` should be called by some async work</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = callbackTask;</span><br></pre></td></tr></table></figure>

<p>如需通过 callback 把任务（task）中的错误告知 gulp，请将 Error 作为 callback 的唯一参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callbackError</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `cb()` should be called by some async work</span></span><br><span class="line">  cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'kaboom'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = callbackError;</span><br></pre></td></tr></table></figure>

<p>然而，你通常会将此 callback 函数传递给另一个 API ，而不是自己调用它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passingCallback</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  fs.access(<span class="string">'gulpfile.js'</span>, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = passingCallback;</span><br></pre></td></tr></table></figure>

<h2 id="gulp-不再支持同步任务（Synchronous-tasks）"><a href="#gulp-不再支持同步任务（Synchronous-tasks）" class="headerlink" title="gulp 不再支持同步任务（Synchronous tasks）"></a>gulp 不再支持同步任务（Synchronous tasks）</h2><p>gulp 不再支持同步任务（Synchronous tasks）了。因为同步任务常常会导致难以调试的细微错误，例如忘记从任务（task）中返回 stream。</p>
<p>当你看到 “Did you forget to signal async completion?” 警告时，说明你并未使用前面提到的返回方式。你需要使用 callback 或返回 stream、promise、event emitter、child process、observable 来解决此问题。</p>
<h2 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async/await"></a>使用 async/await</h2><p>如果不使用前面提供到几种方式，你还可以将任务（task）定义为一个 async 函数，它将利用 promise 对你的任务（task）进行包装。这将允许你使用 await 处理 promise，并使用其他同步代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; version &#125; = fs.readFileSync(<span class="string">'package.json'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(version);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'some result'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = asyncAwaitTask;</span><br></pre></td></tr></table></figure>


<h1 id="处理文件"><a href="#处理文件" class="headerlink" title="处理文件"></a>处理文件</h1><p>gulp 暴露了 src() 和 dest() 方法用于处理计算机上存放的文件。</p>
<p>src() 接受 glob 参数，并从文件系统中读取文件然后生成一个 Node 流（stream）。它将所有匹配的文件读取到内存中并通过流（stream）进行处理。</p>
<p>由 src() 产生的流（stream）应当从任务（task）中返回并发出异步完成的信号，就如 创建任务（task） 文档中所述。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流（stream）所提供的主要的 API 是 .pipe() 方法，用于连接转换流（Transform streams）或可写流（Writable streams）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dest() 接受一个输出目录作为参数，并且它还会产生一个 Node 流（stream），通常作为终止流（terminator stream）。当它接收到通过管道（pipeline）传输的文件时，它会将文件内容及文件属性写入到指定的目录中。gulp 还提供了 symlink() 方法，其操作方式类似 dest()，但是创建的是链接而不是文件（ 详情请参阅 symlink() ）。</p>
<p>大多数情况下，利用 .pipe() 方法将插件放置在 src() 和 dest() 之间，并转换流（stream）中的文件。</p>
<h2 id="向流（stream）中添加文件"><a href="#向流（stream）中添加文件" class="headerlink" title="向流（stream）中添加文件"></a>向流（stream）中添加文件</h2><p>src() 也可以放在管道（pipeline）的中间，以根据给定的 glob 向流（stream）中添加文件。新加入的文件只对后续的转换可用。如果 glob 匹配的文件与之前的有重复，仍然会再次添加文件。</p>
<p>这对于在添加普通的 JavaScript 文件之前先转换部分文件的场景很有用，添加新的文件后可以对所有文件统一进行压缩并混淆（uglifying）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(src(<span class="string">'vendor/*.js'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分阶段输出"><a href="#分阶段输出" class="headerlink" title="分阶段输出"></a>分阶段输出</h2><p>dest() 可以用在管道（pipeline）中间用于将文件的中间状态写入文件系统。当接收到一个文件时，当前状态的文件将被写入文件系统，文件路径也将被修改以反映输出文件的新位置，然后该文件继续沿着管道（pipeline）传输。</p>
<p>此功能可用于在同一个管道（pipeline）中创建未压缩（unminified）和已压缩（minified）的文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    .pipe(babel())</span><br><span class="line">    .pipe(src(<span class="string">'vendor/*.js'</span>))</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>))</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(rename(&#123; <span class="attr">extname</span>: <span class="string">'.min.js'</span> &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式：流动（streaming）、缓冲（buffered）和空（empty）模式"><a href="#模式：流动（streaming）、缓冲（buffered）和空（empty）模式" class="headerlink" title="模式：流动（streaming）、缓冲（buffered）和空（empty）模式"></a>模式：流动（streaming）、缓冲（buffered）和空（empty）模式</h2><p>src() 可以工作在三种模式下：缓冲（buffering）、流动（streaming）和空（empty）模式。这些模式可以通过对 src() 的 buffer 和 read 参数 进行设置。</p>
<p>缓冲（Buffering）模式是默认模式，将文件内容加载内存中。插件通常运行在缓冲（buffering）模式下，并且许多插件不支持流动（streaming）模式。<br>流动（Streaming）模式的存在主要用于操作无法放入内存中的大文件，例如巨幅图像或电影。文件内容从文件系统中以小块的方式流式传输，而不是一次性全部加载。如果需要流动（streaming）模式，请查找支持此模式的插件或自己编写。<br>空（Empty）模式不包含任何内容，仅在处理文件元数据时有用。</p>
<h1 id="Glob-详解"><a href="#Glob-详解" class="headerlink" title="Glob 详解"></a>Glob 详解</h1><p>glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件。</p>
<p>src() 方法接受一个 glob 字符串或由多个 glob 字符串组成的数组作为参数，用于确定哪些文件需要被操作。glob 或 glob 数组必须至少匹配到一个匹配项，否则 src() 将报错。当使用 glob 数组时，将按照每个 glob 在数组中的位置依次执行匹配 - 这尤其对于取反（negative） glob 有用。</p>
<h2 id="字符串片段与分隔符"><a href="#字符串片段与分隔符" class="headerlink" title="字符串片段与分隔符"></a>字符串片段与分隔符</h2><p>字符串片段（segment）是指两个分隔符之间的所有字符组成的字符串。在 glob 中，分隔符永远是 / 字符 - 不区分操作系统 - 即便是在采用 \ 作为分隔符的 Windows 操作系统中。在 glob 中，\ 字符被保留作为转义符使用。</p>
<p>如下， * 被转义了，因此，* 将被作为一个普通字符使用，而不再是通配符了。</p>
<p><code>&#39;glob_with_uncommon_\\*_character.js&#39;</code></p>
<p>避免使用 Node 的 path 类方法来创建 glob，例如 path.join。在 Windows 中，由于 Node 使用 \ 作为路径分隔符，因此将会产生一个无效的 glob。还要避免使用 __dirname 和 __filename 全局变量，由于同样的原因，process.cwd() 方法也要避免使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> invalidGlob = path.join(__dirname, <span class="string">'src/*.js'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="特殊字符：-一个星号"><a href="#特殊字符：-一个星号" class="headerlink" title="特殊字符： * (一个星号)"></a>特殊字符： * (一个星号)</h2><p>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用。</p>
<p>下面这个 glob 能够匹配类似 index.js 的文件，但是不能匹配类似 scripts/index.js 或 scripts/nested/index.js 的文件。</p>
<p><code>&#39;*.js&#39;</code></p>
<h2 id="特殊字符：-两个星号"><a href="#特殊字符：-两个星号" class="headerlink" title="特殊字符： ** (两个星号)"></a>特殊字符： ** (两个星号)</h2><p>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用。请确保适当地限制带有两个星号的 glob 的使用，以避免匹配大量不必要的目录。</p>
<p>下面这个 glob 被适当地限制在 scripts/ 目录下。它将匹配类似 scripts/index.js、scripts/nested/index.js 和 scripts/nested/twice/index.js 的文件。</p>
<p><code>&#39;scripts/**/*.js&#39;</code></p>
<p>在上面的示例中，如果没有 scripts/ 这个前缀做限制，node_modules 目录下的所有目录或其他目录也都将被匹配。</p>
<h2 id="特殊字符：-取反"><a href="#特殊字符：-取反" class="headerlink" title="特殊字符： ! (取反)"></a>特殊字符： ! (取反)</h2><p>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面。第一个 glob 匹配到一组匹配项，然后后面的取反 glob 删除这些匹配项中的一部分。如果取反 glob 只是由普通字符组成的字符串，则执行效率是最高的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'script/**/*.js'</span>, <span class="string">'!scripts/vendor/'</span>]</span><br></pre></td></tr></table></figure>

<p>如果任何非取反（non-negative）的 glob 跟随着一个取反（negative） glob，任何匹配项都不会被删除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'script/**/*.js'</span>, <span class="string">'!scripts/vendor/'</span>, <span class="string">'scripts/vendor/react.js'</span>]</span><br></pre></td></tr></table></figure>

<p>取反（negative） glob 可以作为对带有两个星号的 glob 的限制手段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'**/*.js'</span>, <span class="string">'!node_modules/'</span>]</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，如果取反（negative）glob 是 !node_modules/<em>*/</em>.js，那么各匹配项都必须与取反 glob 进行比较，这将导致执行速度极慢。</p>
<h2 id="匹配重叠（Overlapping-globs）"><a href="#匹配重叠（Overlapping-globs）" class="headerlink" title="匹配重叠（Overlapping globs）"></a>匹配重叠（Overlapping globs）</h2><p>两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 src() 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 src() 调用时产生的匹配重叠是不会被去重的。</p>
<h2 id="进阶资料"><a href="#进阶资料" class="headerlink" title="进阶资料"></a>进阶资料</h2><p>关于如何在 gulp 中使用 glob 的知识都已经在在上面的文档中讲解了。如果你还希望获取更多进阶资料，请参考下面列出的部分：</p>
<ul>
<li><a href="https://github.com/micromatch/micromatch" target="_blank" rel="noopener">Micromatch Documentation</a></li>
<li><a href="https://github.com/isaacs/node-glob#glob-primer" target="_blank" rel="noopener">node-glob’s Glob Primer</a></li>
<li><a href="https://github.com/begin/globbing#what-is-globbing" target="_blank" rel="noopener">Begin’s Globbing Documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Glob_(programming)" target="_blank" rel="noopener">Wikipedia’s Glob Page</a></li>
</ul>
<h1 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h1><p>Gulp 插件实质上是 Node 转换流（Transform Streams），它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 .pipe() 方法并放在 src() 和 dest() 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容。</p>
<p>托管在 npm 上的插件 - 标记有 “gulpplugin” 和 “gulpfriendly” 关键词 - 可以在 插件搜索页面 上浏览和搜索。</p>
<p>每个插件应当只完成必要的工作，因此你可以把它们像构建块一样连接在一起。获得想要的结果可能需要把一组插件组合在一起使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">const</span> rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    <span class="comment">// gulp-uglify 插件并不改变文件名</span></span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    <span class="comment">// 因此使用 gulp-rename 插件修改文件的扩展名</span></span><br><span class="line">    .pipe(rename(&#123; <span class="attr">extname</span>: <span class="string">'.min.js'</span> &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="是否需要插件？"><a href="#是否需要插件？" class="headerlink" title="是否需要插件？"></a>是否需要插件？</h2><p>并非 gulp 中的一切都需要用插件来完成。虽然它们是一种快速上手的方法，但许多操作都应当通过使用独立的功能模块或库来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; rollup &#125; = <span class="built_in">require</span>(<span class="string">'rollup'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rollup 提供了基于 promise 的 API，在 `async` 任务（task）中工作的很好</span></span><br><span class="line">exports.default = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bundle = <span class="keyword">await</span> rollup.rollup(&#123;</span><br><span class="line">    input: <span class="string">'src/index.js'</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bundle.write(&#123;</span><br><span class="line">    file: <span class="string">'output/bundle.js'</span>,</span><br><span class="line">    format: <span class="string">'iife'</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件应当总是用来转换文件的。其他操作都应该使用（非插件的） Node 模块或库来实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> del = <span class="built_in">require</span>(<span class="string">'delete'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接使用 `delete` 模块，避免使用 gulp-rimraf 插件</span></span><br><span class="line">  del([<span class="string">'output/*.js'</span>], cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件插件"><a href="#条件插件" class="headerlink" title="条件插件"></a>条件插件</h2><p>因为插件的操作不应该针对特定文件类型，因此你可能需要使用像 gulp-if 之类的插件来完成转换某些文件的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> gulpif = <span class="built_in">require</span>(<span class="string">'gulp-if'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isJavaScript</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断文件的扩展名是否是 '.js'</span></span><br><span class="line">  <span class="keyword">return</span> file.extname === <span class="string">'.js'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在同一个管道（pipeline）上处理 JavaScript 和 CSS 文件</span></span><br><span class="line">  <span class="keyword">return</span> src([<span class="string">'src/*.js'</span>, <span class="string">'src/*.css'</span>])</span><br><span class="line">    <span class="comment">// 只对 JavaScript 文件应用 gulp-uglify 插件</span></span><br><span class="line">    .pipe(gulpif(isJavaScript, uglify()))</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内联插件（Inline-plugins）"><a href="#内联插件（Inline-plugins）" class="headerlink" title="内联插件（Inline plugins）"></a>内联插件（Inline plugins）</h2><p>内联插件是一次性的转换流（Transform Streams），你可以通过在 gulpfile 文件直接书写需要的功能。</p>
<p>在两种情况下，创建内联插件很有用：</p>
<ul>
<li>避免自己创建并维护插件。</li>
<li>避免 fork 一个已经存在的插件并添加自己所需的功能。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'uglify-js'</span>);</span><br><span class="line"><span class="keyword">const</span> through2 = <span class="built_in">require</span>(<span class="string">'through2'</span>);</span><br><span class="line"></span><br><span class="line">exports.default = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/*.js'</span>)</span><br><span class="line">    <span class="comment">// 创建一个内联插件，从而避免使用 gulp-uglify 插件</span></span><br><span class="line">    .pipe(through2.obj(<span class="function"><span class="keyword">function</span>(<span class="params">file, _, cb</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isBuffer()) &#123;</span><br><span class="line">        <span class="keyword">const</span> code = uglify.minify(file.contents.toString())</span><br><span class="line">        file.contents = Buffer.from(code)</span><br><span class="line">      &#125;</span><br><span class="line">      cb(<span class="literal">null</span>, file);</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(dest(<span class="string">'output/'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h1><p>gulp api 中的 watch() 方法利用文件系统的监控程序（file system watcher）将 globs 与 任务（task） 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 异步完成 信号，它将永远不会再次运行了。</p>
<p>此 API 的默认设置是基于通常的使用场景的，而且提供了内置的延迟和排队机制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch, series &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以只关联一个任务</span></span><br><span class="line">watch(<span class="string">'src/*.css'</span>, css);</span><br><span class="line"><span class="comment">// 或者关联一个任务组合</span></span><br><span class="line">watch(<span class="string">'src/*.js'</span>, series(clean, javascript));</span><br></pre></td></tr></table></figure>

<h2 id="警告：避免同步任务"><a href="#警告：避免同步任务" class="headerlink" title="警告：避免同步任务"></a>警告：避免同步任务</h2><p>就像注册到任务系统中的任务（task）一样，与文件监控程序关联的任务（task）不能是同步任务（synchronous taks）。如果你将同步任务（task）关联到监控程序，则无法确定任务（task）的完成情况，任务（task）将不会再次运行（假定当前正在运行）。</p>
<p>由于文件监控程序会让你的 Node 进程保持持续运行，因此不会有错误或警告产生。由于进程没有退出，因此无法确定任务（task）是否已经完成还是运行了很久很久了。</p>
<h2 id="可监控的事件"><a href="#可监控的事件" class="headerlink" title="可监控的事件"></a>可监控的事件</h2><p>默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）。 如果你需要使用不同的事件，你可以在调用 watch() 方法时通过 events 参数进行指定。可用的事件有 ‘add’、’addDir’、’change’、’unlink’、’unlinkDir’、’ready’、’error’。此外，还有一个 ‘all’ 事件，它表示除 ‘ready’ 和 ‘error’ 之外的所有事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有事件都将被监控</span></span><br><span class="line">watch(<span class="string">'src/*.js'</span>, &#123; <span class="attr">events</span>: <span class="string">'all'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="初次执行"><a href="#初次执行" class="headerlink" title="初次执行"></a>初次执行</h2><p>调用 watch() 之后，关联的任务（task）是不会被立即执行的，而是要等到第一次文件修之后才执行。</p>
<p>如需在第一次文件修改之前执行，也就是调用 watch() 之后立即执行，请将 ignoreInitial 参数设置为 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联的任务（task）将在启动时执行</span></span><br><span class="line">watch(<span class="string">'src/*.js'</span>, &#123; <span class="attr">ignoreInitial</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>watch() 方法能够保证当前执行的任务（task）不会再次并发执行。当文件监控程序关联的任务（task）正在运行时又有文件被修改了，那么所关联任务的这次新的执行将被放到执行队列中等待，直到上一次关联任务执行完之后才能运行。每一次文件修改只产生一次关联任务的执行并放入队列中。</p>
<p>如需禁止队列，请将 queue 参数设置为 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次文件修改之后关联任务都将执行（有可能并发执行）</span></span><br><span class="line">watch(<span class="string">'src/*.js'</span>, &#123; <span class="attr">queue</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>文件更改之后，只有经过 200 毫秒的延迟之后，文件监控程序所关联的任务（task）才会被执行。这是为了避免在同使更改许多文件时（例如查找和替换操作）过早启动任务（taks）的执行。</p>
<p>如需调整延迟时间，请为 delay 参数设置一个正整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件第一次修改之后要等待 500 毫秒才执行关联的任务</span></span><br><span class="line">watch(<span class="string">'src/*.js'</span>, &#123; <span class="attr">delay</span>: <span class="number">500</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body omitted</span></span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="使用监控程序实例"><a href="#使用监控程序实例" class="headerlink" title="使用监控程序实例"></a>使用监控程序实例</h2><p>你可能不会使用到此功能，但是如果你需要对被修改的文件进行完全的掌控 （例如访问文件路径或元数据）请使用从 watch() 返回的 chokidar 实例。</p>
<p>注意： 返回的 chokidar 实例没有队列、延迟和异步完成（async completion）这些功能。</p>
<h2 id="可选的依赖项"><a href="#可选的依赖项" class="headerlink" title="可选的依赖项"></a>可选的依赖项</h2><p>Gulp 有一个名为 fsevents 的可选依赖项，他是一个特定于 Mac 系统的文件监控程序。如果你看到安装 fsevents 时出现的警告信息 - “npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents” - 这并不是什么问题，忽略即可。 如果跳过 fsevents 的安装，将使用一个备用文件监控程序，后续在 gulpfile 中产生的任何错误都将与此警告无关。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/29/npm/" rel="prev" title="npm">
      <i class="fa fa-chevron-left"></i> npm
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/29/linux-%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/" rel="next" title="linux网络设置">
      linux网络设置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

    <div id="gitmentContainer"></div>
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#task"><span class="nav-number">1.</span> <span class="nav-text">task</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#导出任务"><span class="nav-number">1.1.</span> <span class="nav-text">导出任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合任务"><span class="nav-number">1.2.</span> <span class="nav-text">组合任务</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步执行"><span class="nav-number">2.</span> <span class="nav-text">异步执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任务（task）完成通知"><span class="nav-number">2.1.</span> <span class="nav-text">任务（task）完成通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回-streams"><span class="nav-number">2.2.</span> <span class="nav-text">返回 streams</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回-promise"><span class="nav-number">2.3.</span> <span class="nav-text">返回 promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回-event-emitter"><span class="nav-number">2.4.</span> <span class="nav-text">返回 event emitter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回-child-process"><span class="nav-number">2.5.</span> <span class="nav-text">返回 child process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回-observable"><span class="nav-number">2.6.</span> <span class="nav-text">返回 observable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-callback"><span class="nav-number">2.7.</span> <span class="nav-text">使用 callback</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gulp-不再支持同步任务（Synchronous-tasks）"><span class="nav-number">2.8.</span> <span class="nav-text">gulp 不再支持同步任务（Synchronous tasks）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-async-await"><span class="nav-number">2.9.</span> <span class="nav-text">使用 async&#x2F;await</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理文件"><span class="nav-number">3.</span> <span class="nav-text">处理文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#向流（stream）中添加文件"><span class="nav-number">3.1.</span> <span class="nav-text">向流（stream）中添加文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分阶段输出"><span class="nav-number">3.2.</span> <span class="nav-text">分阶段输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模式：流动（streaming）、缓冲（buffered）和空（empty）模式"><span class="nav-number">3.3.</span> <span class="nav-text">模式：流动（streaming）、缓冲（buffered）和空（empty）模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Glob-详解"><span class="nav-number">4.</span> <span class="nav-text">Glob 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串片段与分隔符"><span class="nav-number">4.1.</span> <span class="nav-text">字符串片段与分隔符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊字符：-一个星号"><span class="nav-number">4.2.</span> <span class="nav-text">特殊字符： * (一个星号)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊字符：-两个星号"><span class="nav-number">4.3.</span> <span class="nav-text">特殊字符： ** (两个星号)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊字符：-取反"><span class="nav-number">4.4.</span> <span class="nav-text">特殊字符： ! (取反)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配重叠（Overlapping-globs）"><span class="nav-number">4.5.</span> <span class="nav-text">匹配重叠（Overlapping globs）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶资料"><span class="nav-number">4.6.</span> <span class="nav-text">进阶资料</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用插件"><span class="nav-number">5.</span> <span class="nav-text">使用插件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#是否需要插件？"><span class="nav-number">5.1.</span> <span class="nav-text">是否需要插件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件插件"><span class="nav-number">5.2.</span> <span class="nav-text">条件插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联插件（Inline-plugins）"><span class="nav-number">5.3.</span> <span class="nav-text">内联插件（Inline plugins）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件监控"><span class="nav-number">6.</span> <span class="nav-text">文件监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#警告：避免同步任务"><span class="nav-number">6.1.</span> <span class="nav-text">警告：避免同步任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可监控的事件"><span class="nav-number">6.2.</span> <span class="nav-text">可监控的事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初次执行"><span class="nav-number">6.3.</span> <span class="nav-text">初次执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#队列"><span class="nav-number">6.4.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟"><span class="nav-number">6.5.</span> <span class="nav-text">延迟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用监控程序实例"><span class="nav-number">6.6.</span> <span class="nav-text">使用监控程序实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选的依赖项"><span class="nav-number">6.7.</span> <span class="nav-text">可选的依赖项</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jinwen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jinwen</span>
</div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
  // https://imsun.net/posts/gitment-introduction/
  var gitment = new Gitment({
    // id: 'tags/index.html', // 可选。默认为 location.href
    id: location.href,
    owner: 'jinven',
    repo: 'jinven.github.io',
    oauth: {
      client_id: 'c632308a327582f31107',
      client_secret: '06592fcf5ed4c08e218fbf0c6ebe2dce1241d054',
    },
  })
  if(document.getElementById('gitmentContainer')){
    gitment.render('gitmentContainer')
  }
</script>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

</body>
</html>
